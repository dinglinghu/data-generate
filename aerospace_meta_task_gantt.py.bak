"""
航天元任务规划甘特图生成器
基于元任务定义和可见元任务定义创建专业的任务规划甘特图
"""

import json
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from matplotlib.patches import Rectangle
import seaborn as sns
from matplotlib.patches import Patch
import matplotlib.patches as mpatches
import yaml
import sys
import os
from pathlib import Path

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

class AerospaceMetaTaskGantt:
    """航天元任务规划甘特图生成器"""

    def __init__(self, config_path="config/config.yaml"):
        # 加载配置文件
        self.config = self._load_config(config_path)

        # 获取可视化配置
        viz_config = self.config.get('visualization', {})
        gantt_config = viz_config.get('gantt_chart', {})

        # 颜色配置
        self.colors = gantt_config.get('colors', {})

        # 图表配置
        self.figure_config = {
            'size': gantt_config.get('figure_size', [24, 16]),
            'height_ratios': gantt_config.get('height_ratios', [2, 3]),
            'dpi': gantt_config.get('dpi', 300)
        }

        # 时间轴配置
        self.time_config = gantt_config.get('time_axis', {})

        # 任务条配置
        self.task_config = gantt_config.get('task_bars', {})

        # Y轴配置
        self.y_config = gantt_config.get('y_axis', {})

        # 文字配置
        self.text_config = gantt_config.get('text', {})

        # 网格配置
        self.grid_config = gantt_config.get('grid', {})

    def _load_config(self, config_path):
        """加载配置文件"""
        try:
            config_file = Path(config_path)
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f)
            else:
                print(f"⚠️ 配置文件不存在: {config_path}，使用默认配置")
                return self._get_default_config()
        except Exception as e:
            print(f"❌ 加载配置文件失败: {e}，使用默认配置")
            return self._get_default_config()

    def _get_default_config(self):
        """获取默认配置"""
        return {
            'visualization': {
                'gantt_chart': {
                    'figure_size': [24, 16],
                    'height_ratios': [2, 3],
                    'dpi': 300,
                    'time_axis': {
                        'buffer_minutes': 5,
                        'default_window_hours': 2,
                        'hour_interval': 1,
                        'minute_interval': 30,
                        'label_rotation': 45
                    },
                    'task_bars': {
                        'meta_task': {
                            'height': 0.4,
                            'linewidth': 1,
                            'alpha_real': 0.9,
                            'alpha_virtual': 0.6,
                            'min_duration_for_label': 30
                        },
                        'visible_task': {
                            'height': 0.7,
                            'linewidth_visible': 2,
                            'linewidth_virtual': 1,
                            'alpha_visible': 0.9,
                            'alpha_virtual': 0.6,
                            'min_duration_for_label': 30
                        }
                    },
                    'y_axis': {
                        'spacing_between_missiles': 0.5,
                        'spacing_between_combos': 0.5,
                        'label_fontsize_meta': 10,
                        'label_fontsize_visible': 9
                    },
                    'text': {
                        'title_fontsize': 18,
                        'subtitle_fontsize': 14,
                        'label_fontsize': 12,
                        'task_label_fontsize': 8,
                        'legend_fontsize': 10,
                        'legend_alpha': 0.9
                    },
                    'grid': {
                        'enable': True,
                        'alpha': 0.3,
                        'linestyle': "-",
                        'linewidth': 0.5
                    },
                    'colors': {
                        'background': '#fafafa',
                        'grid_major': '#e0e0e0',
                        'text_primary': '#212121',
                        'visible_meta_task': '#4caf50',
                        'visible_meta_border': '#2e7d32',
                        'virtual_atomic_task': '#ff9800',
                        'virtual_atomic_border': '#f57c00',
                        'visible_virtual_atomic_task': '#e0e0e0',
                        'visible_virtual_atomic_border': '#1976d2',
                        'real_meta_task': '#4caf50',
                        'real_meta_border': '#2e7d32',
                        'virtual_meta_task': '#e8f4fd',
                        'virtual_meta_border': '#1e88e5',
                        'meta_task_background': '#e8f4fd',
                        'meta_task_border': '#1e88e5',
                        'meta_task_text': '#0d47a1'
                    }
                }
            }
        }
    
    def load_data(self, json_file_path):
        """加载元任务数据"""
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # 选择第一个数据采样点
        if isinstance(data, list):
            self.sample_data = data[0]
        else:
            self.sample_data = data
            
        collection_time = self.sample_data.get('collection_time', 'Unknown')
        print(f"✅ 数据加载完成，采样时间: {collection_time}")
        
        # 解析数据结构
        self.meta_tasks = self.sample_data.get('meta_tasks', {})
        self.visible_meta_tasks = self.sample_data.get('visible_meta_tasks', {})
        
        print(f"📊 元任务数据: {len(self.meta_tasks.get('meta_tasks', {}))} 个导弹")
        print(f"👁️ 可见元任务数据: {len(self.visible_meta_tasks.get('constellation_visible_task_sets', {}))} 颗卫星")
    
    def parse_time(self, time_str):
        """解析时间字符串"""
        try:
            if isinstance(time_str, str):
                # ISO格式：2025-07-25T14:07:02
                if 'T' in time_str:
                    return datetime.fromisoformat(time_str.replace('Z', '+00:00'))
                # 标准格式：2025-07-25 14:07:02
                elif '-' in time_str and ':' in time_str:
                    return datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S")
                # STK格式：25 Jul 2025 14:07:02.000
                else:
                    return datetime.strptime(time_str, "%d %b %Y %H:%M:%S.%f")
            return time_str
        except:
            try:
                # 备用STK格式：25 Jul 2025 14:07:02
                return datetime.strptime(time_str, "%d %b %Y %H:%M:%S")
            except:
                print(f"⚠️ 无法解析时间格式: {time_str}")
                return datetime.now()
    
    def extract_meta_task_data(self):
        """提取元任务数据"""
        meta_task_data = []
        
        # 获取元任务规划周期信息
        planning_info = self.meta_tasks.get('planning_cycle_info', {})
        planning_start_str = planning_info.get('planning_start_time', '')
        planning_end_str = planning_info.get('planning_end_time', '')

        if planning_start_str and planning_end_str:
            planning_start = self.parse_time(planning_start_str)
            planning_end = self.parse_time(planning_end_str)
            print(f"📅 元任务规划周期: {planning_start} → {planning_end}")
        else:
            print(f"📅 元任务规划周期: 从数据中自动推导")
        
        # 处理每个导弹的元任务
        missile_tasks = self.meta_tasks.get('meta_tasks', {})
        
        for missile_id, missile_data in missile_tasks.items():
            atomic_tasks = missile_data.get('atomic_tasks', [])
            

            
            # 添加每个元子任务（区分真实任务和虚拟任务）
            for task in atomic_tasks:
                task_type = task.get('task_type', 'atomic_meta_task')
                is_real_task = task_type == 'real_meta_task'
                is_virtual_task = task_type == 'virtual_meta_task'

                # 确定任务类别和名称
                if is_real_task:
                    category = '真实元子任务'
                    task_name = f'{missile_id} 真实任务 {task.get("task_index", "")}'
                    task_level = 'real_atomic'
                elif is_virtual_task:
                    category = '虚拟元子任务'
                    task_name = f'{missile_id} 虚拟任务 {task.get("task_index", "")}'
                    task_level = 'virtual_atomic'
                else:
                    category = '元子任务'
                    task_name = f'{missile_id} 元子任务 {task.get("task_index", "")}'
                    task_level = 'atomic'

                meta_task_data.append({
                    'Type': 'meta_atomic_task',
                    'MissileID': missile_id,
                    'TaskID': task.get('task_id', ''),
                    'TaskIndex': task.get('task_index', 0),
                    'TaskName': task_name,
                    'Start': self.parse_time(task['start_time']),
                    'End': self.parse_time(task['end_time']),
                    'Duration': task.get('duration_seconds', 0),
                    'Category': category,
                    'Level': task_level,
                    'TaskType': task_type,
                    'IsRealTask': is_real_task,
                    'IsVirtualTask': is_virtual_task
                })
        
        return pd.DataFrame(meta_task_data)
    
    def extract_visible_meta_task_data(self):
        """提取可见元任务数据"""
        visible_task_data = []
        
        constellation_sets = self.visible_meta_tasks.get('constellation_visible_task_sets', {})
        
        for satellite_id, satellite_data in constellation_sets.items():
            missile_tasks = satellite_data.get('missile_tasks', {})
            
            for missile_id, task_data in missile_tasks.items():
                # 处理可见元任务
                visible_tasks = task_data.get('visible_tasks', [])
                for task in visible_tasks:
                    visible_task_data.append({
                        'Type': 'visible_meta_task',
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'TaskID': task.get('task_id', ''),
                        'TaskIndex': task.get('task_index', 0),
                        'TaskName': f'{satellite_id} → {missile_id} 可见元任务',
                        'Start': self.parse_time(task['start_time']),
                        'End': self.parse_time(task['end_time']),
                        'Duration': task.get('duration_seconds', 0),
                        'Category': '可见元任务',
                        'Level': 'visible',
                        'VisibilityInfo': task.get('visibility_info', {}),
                        'CoverageRatio': task.get('visibility_info', {}).get('coverage_ratio', 1.0)
                    })
                
                # 处理虚拟原子任务（采样显示）
                virtual_tasks = task_data.get('virtual_tasks', [])
                for i, task in enumerate(virtual_tasks):
                    if i % 10 == 0:  # 每10个显示1个，避免过于密集
                        visible_task_data.append({
                            'Type': 'virtual_atomic_task',
                            'SatelliteID': satellite_id,
                            'MissileID': missile_id,
                            'TaskID': task.get('task_id', ''),
                            'TaskIndex': task.get('task_index', 0),
                            'TaskName': f'{satellite_id} → {missile_id} 虚拟原子任务',
                            'Start': self.parse_time(task['start_time']),
                            'End': self.parse_time(task['end_time']),
                            'Duration': task.get('duration_seconds', 0),
                            'Category': '虚拟原子任务',
                            'Level': 'virtual',
                            'VisibilityInfo': task.get('visibility_info', {})
                        })
        
        return pd.DataFrame(visible_task_data)
    
    def create_professional_gantt_chart(self, meta_df, visible_df, time_window_hours=None, output_path=None):
        """创建专业的航天元任务甘特图，自动根据数据范围确定时间轴"""

        # 创建图形
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=self.figure_config['size'],
                                       gridspec_kw={'height_ratios': self.figure_config['height_ratios']})
        fig.patch.set_facecolor(self.colors.get('background', '#fafafa'))

        # 智能确定时间窗口 - 以元任务的时间轴为准
        if not meta_df.empty:
            # 优先使用元任务的时间范围
            meta_start_times = meta_df['Start'].tolist()
            meta_end_times = meta_df['End'].tolist()

            # 确定元任务的时间范围
            data_min_time = min(meta_start_times)
            data_max_time = max(meta_end_times)

            # 添加缓冲时间
            buffer_minutes = self.time_config.get('buffer_minutes', 5)
            min_time = data_min_time - timedelta(minutes=buffer_minutes)
            max_time = data_max_time + timedelta(minutes=buffer_minutes)

            # 如果指定了时间窗口，确保不小于数据范围
            if time_window_hours and time_window_hours > 0:
                window_max_time = min_time + timedelta(hours=time_window_hours)
                if window_max_time > max_time:
                    max_time = window_max_time

            # 计算实际时间跨度
            actual_duration = max_time - min_time
            duration_hours = actual_duration.total_seconds() / 3600

            print(f"🕐 元任务时间范围: {data_min_time} → {data_max_time}")
            print(f"🕐 图表时间范围: {min_time} → {max_time}")
            print(f"⏱️ 时间跨度: {duration_hours:.2f} 小时")
            print(f"📊 原始元任务数据: {len(meta_df)} 条")
            print(f"👁️ 原始可见任务数据: {len(visible_df)} 条")

            # 使用元任务的时间范围筛选可见任务数据
            meta_filtered = meta_df
            if not visible_df.empty:
                visible_filtered = visible_df[
                    (visible_df['Start'] >= min_time) &
                    (visible_df['End'] <= max_time)
                ].copy()
            else:
                visible_filtered = visible_df

            print(f"📊 筛选后元任务数据: {len(meta_filtered)} 条")
            print(f"👁️ 筛选后可见任务数据: {len(visible_filtered)} 条")

        elif not visible_df.empty:
            # 如果没有元任务但有可见任务，使用可见任务的时间范围
            visible_start_times = visible_df['Start'].tolist()
            visible_end_times = visible_df['End'].tolist()

            data_min_time = min(visible_start_times)
            data_max_time = max(visible_end_times)

            buffer_minutes = self.time_config.get('buffer_minutes', 5)
            min_time = data_min_time - timedelta(minutes=buffer_minutes)
            max_time = data_max_time + timedelta(minutes=buffer_minutes)

            meta_filtered = meta_df
            visible_filtered = visible_df
            print("⚠️ 没有元任务数据，使用可见任务时间范围")
        else:
            # 如果没有数据，设置默认时间范围
            min_time = datetime.now()
            default_hours = time_window_hours or self.time_config.get('default_window_hours', 2)
            max_time = min_time + timedelta(hours=default_hours)
            meta_filtered = meta_df
            visible_filtered = visible_df
            print("⚠️ 没有任何任务数据")
        
        # 绘制元任务甘特图
        self._draw_meta_task_gantt(ax1, meta_filtered, min_time, max_time)
        
        # 绘制可见元任务甘特图
        self._draw_visible_meta_task_gantt(ax2, visible_filtered, min_time, max_time)
        
        # 设置整体标题
        collection_time = self.sample_data.get('collection_time', 'Unknown')
        title_fontsize = self.text_config.get('title_fontsize', 18)
        fig.suptitle(
            f'航天元任务规划甘特图\n数据采样时间: {collection_time}',
            fontsize=title_fontsize, fontweight='bold',
            color=self.colors.get('text_primary', '#212121')
        )
        
        plt.tight_layout()
        
        # 保存图表 - 支持自定义输出路径
        if output_path is None:
            output_path = 'output/charts/aerospace_meta_task_gantt.png'

        import os
        output_dir = os.path.dirname(output_path)
        if output_dir:  # 只有当目录不为空时才创建
            os.makedirs(output_dir, exist_ok=True)
        dpi = self.figure_config.get('dpi', 300)

        try:
            plt.savefig(output_path, dpi=dpi, bbox_inches='tight',
                       facecolor=self.colors.get('background', '#fafafa'))
            print(f"✅ 专业航天元任务甘特图已保存到: {output_path}")
            save_success = True
        except Exception as e:
            print(f"❌ 保存甘特图失败: {e}")
            # 尝试保存到当前目录
            fallback_path = "aerospace_meta_task_gantt.png"
            try:
                plt.savefig(fallback_path, dpi=dpi, bbox_inches='tight',
                           facecolor=self.colors.get('background', '#fafafa'))
                print(f"✅ 甘特图已保存到备用位置: {fallback_path}")
                output_path = fallback_path
                save_success = True
            except Exception as e2:
                print(f"❌ 备用保存也失败: {e2}")
                save_success = False

        return fig, (ax1, ax2), output_path, save_success

    def _draw_meta_task_gantt(self, ax, meta_df, min_time, max_time):
        """绘制元任务甘特图"""
        ax.set_facecolor(self.colors['background'])

        if meta_df.empty:
            ax.text(0.5, 0.5, '无元任务数据', ha='center', va='center',
                   transform=ax.transAxes, fontsize=14)
            return

        # 获取唯一的导弹ID
        unique_missiles = sorted(meta_df['MissileID'].unique())

        # 创建Y轴位置映射
        y_positions = {}
        y_pos = 0

        for missile_id in unique_missiles:
            # 元子任务
            y_positions[f'{missile_id}_atomic'] = y_pos
            y_pos += 1

            y_pos += 0.5  # 导弹间间隔

        # 为元任务填充虚拟任务，确保时间轴完整
        complete_meta_df = self._fill_virtual_tasks_for_meta_timeline(meta_df, min_time, max_time, y_positions)

        # 绘制任务条
        for idx, row in complete_meta_df.iterrows():
            start_time = row['Start']
            end_time = row['End']
            missile_id = row['MissileID']

            # 所有任务都是元子任务
            y_pos = y_positions[f'{missile_id}_atomic']

            # 根据任务类型选择颜色
            task_type = row.get('TaskType', 'atomic_meta_task')
            is_real_task = row.get('IsRealTask', False)
            is_virtual_task = row.get('IsVirtualTask', False)

            if is_real_task or task_type == 'real_meta_task':
                color = self.colors['real_meta_task']
                edgecolor = self.colors['real_meta_border']
                alpha = 0.9
            elif is_virtual_task or task_type == 'virtual_meta_task':
                color = self.colors['virtual_meta_task']
                edgecolor = self.colors['virtual_meta_border']
                alpha = 0.9
            else:
                color = self.colors['meta_task_background']
                edgecolor = self.colors['meta_task_border']
                alpha = 0.9

            linewidth = 1
            height = 0.4

            # 绘制矩形
            rect = Rectangle(
                (mdates.date2num(start_time), y_pos - height/2),
                mdates.date2num(end_time) - mdates.date2num(start_time),
                height,
                facecolor=color,
                alpha=alpha,
                edgecolor=edgecolor,
                linewidth=linewidth
            )
            ax.add_patch(rect)

            # 添加任务标签
            if row['Type'] == 'meta_atomic_task':
                duration_minutes = (end_time - start_time).total_seconds() / 60
                if duration_minutes > 30:  # 只为较长的任务添加标签
                    mid_time = start_time + (end_time - start_time) / 2
                    task_index = row.get('TaskIndex', '')
                    ax.text(
                        mdates.date2num(mid_time), y_pos,
                        str(task_index),
                        ha='center', va='center',
                        fontsize=8, fontweight='bold',
                        color=self.colors['meta_task_text']
                    )

        # 设置Y轴
        y_labels = []
        y_ticks = []
        for missile_id in unique_missiles:
            y_labels.append(f'{missile_id} 元子任务')
            y_ticks.append(y_positions[f'{missile_id}_atomic'])

        ax.set_yticks(y_ticks)
        ax.set_yticklabels(y_labels, fontsize=10)
        ax.set_ylim(-0.5, max(y_ticks) + 1)

        # 设置时间轴
        self._setup_time_axis(ax, min_time, max_time)

        # 设置标题和标签
        ax.set_title('元任务规划时间线', fontsize=14, fontweight='bold',
                    color=self.colors['text_primary'], pad=15)
        ax.set_ylabel('导弹目标', fontsize=12, fontweight='bold')

        # 添加网格
        ax.grid(True, alpha=0.3, color=self.colors['grid_major'], linestyle='-', linewidth=0.5)
        ax.set_axisbelow(True)

    def _draw_visible_meta_task_gantt(self, ax, visible_df, min_time, max_time):
        """绘制可见元任务甘特图 - 按导弹目标组织"""
        ax.set_facecolor(self.colors['background'])

        if visible_df.empty:
            ax.text(0.5, 0.5, '无可见元任务数据', ha='center', va='center',
                   transform=ax.transAxes, fontsize=14)
            return

        # 获取唯一的导弹和卫星
        unique_missiles = sorted(visible_df['MissileID'].unique())
        unique_satellites = sorted(visible_df['SatelliteID'].unique())

        # 创建分层Y轴位置 - 按导弹目标组织
        y_positions = {}
        y_labels = []
        y_pos = 0

        # 获取Y轴间距配置
        y_axis_config = self.config.get('visualization', {}).get('gantt_chart', {}).get('y_axis', {})
        combo_spacing = y_axis_config.get('spacing_between_combos', 1.5)
        missile_spacing = y_axis_config.get('spacing_between_missiles', 1.0)

        for missile_id in unique_missiles:
            # 为每个导弹目标创建一个分组
            missile_satellites = []
            for satellite_id in unique_satellites:
                # 为所有导弹-卫星组合创建Y轴位置，无论是否有数据
                combo_key = f'{missile_id}_{satellite_id}'
                y_positions[combo_key] = y_pos
                y_labels.append(f'{missile_id} → {satellite_id}')
                missile_satellites.append(satellite_id)
                y_pos += combo_spacing  # 使用配置的组合间间隔

            # 为每个导弹分组添加分隔空间
            if missile_satellites:
                y_pos += missile_spacing  # 使用配置的导弹间间隔

        # 为每个导弹-卫星组合生成完整的时间轴填充
        complete_visible_df = self._generate_complete_visible_timeline(visible_df, y_positions, min_time, max_time)

        # 绘制任务条
        for idx, row in complete_visible_df.iterrows():
            start_time = row['Start']
            end_time = row['End']
            satellite_id = row['SatelliteID']
            missile_id = row['MissileID']

            combo_key = f'{missile_id}_{satellite_id}'  # 注意：导弹在前，卫星在后
            if combo_key not in y_positions:
                continue

            y_pos = y_positions[combo_key]

            # 根据任务类型选择颜色和样式
            if row['Type'] == 'visible_meta_task':
                color = self.colors['visible_meta_task']
                alpha = 0.9
                edgecolor = self.colors['visible_meta_border']
                linewidth = 2
                height = 0.7
            else:  # virtual_atomic_task - 使用新的灰色样式
                color = self.colors['visible_virtual_atomic_task']
                alpha = 0.8
                edgecolor = self.colors['visible_virtual_atomic_border']
                linewidth = 1
                height = 0.7  # 统一高度与可见元任务一致

            # 绘制矩形
            rect = Rectangle(
                (mdates.date2num(start_time), y_pos - height/2),
                mdates.date2num(end_time) - mdates.date2num(start_time),
                height,
                facecolor=color,
                alpha=alpha,
                edgecolor=edgecolor,
                linewidth=linewidth
            )
            ax.add_patch(rect)

            # 添加任务标签
            if row['Type'] == 'visible_meta_task':
                duration_minutes = (end_time - start_time).total_seconds() / 60
                if duration_minutes > 30:
                    mid_time = start_time + (end_time - start_time) / 2
                    task_index = row.get('TaskIndex', '')
                    ax.text(
                        mdates.date2num(mid_time), y_pos,
                        f'V{task_index}',
                        ha='center', va='center',
                        fontsize=8, fontweight='bold',
                        color='white'
                    )

        # 设置Y轴
        y_ticks = list(y_positions.values())

        ax.set_yticks(y_ticks)
        ax.set_yticklabels(y_labels, fontsize=9)
        ax.set_ylim(-0.5, max(y_ticks) + 1 if y_ticks else 1)

        # 设置时间轴
        self._setup_time_axis(ax, min_time, max_time)

        # 设置标题和标签
        ax.set_title('可见元任务与虚拟原子任务时间线', fontsize=14, fontweight='bold',
                    color=self.colors['text_primary'], pad=15)
        ax.set_xlabel('时间 (小时:分钟)', fontsize=12, fontweight='bold')
        ax.set_ylabel('导弹目标 → 观测卫星', fontsize=12, fontweight='bold')

        # 添加网格
        ax.grid(True, alpha=0.3, color=self.colors['grid_major'], linestyle='-', linewidth=0.5)
        ax.set_axisbelow(True)

        # 添加图例
        legend_elements = [
            Patch(facecolor=self.colors['visible_meta_task'], alpha=0.9,
                  edgecolor=self.colors['visible_meta_border'], label='可见元任务'),
            Patch(facecolor=self.colors['visible_virtual_atomic_task'], alpha=0.8,
                  edgecolor=self.colors['visible_virtual_atomic_border'], label='虚拟原子任务'),
            Patch(facecolor=self.colors['meta_task_background'], alpha=0.9,
                  edgecolor=self.colors['meta_task_border'], label='元子任务')
        ]
        ax.legend(handles=legend_elements, loc='upper right', fontsize=10, framealpha=0.9)

    def _generate_complete_visible_timeline(self, visible_df, y_positions, min_time, max_time):
        """为每个导弹-卫星组合生成完整的时间轴填充"""
        import pandas as pd
        from datetime import timedelta

        complete_tasks = []

        # 获取所有唯一的导弹和卫星
        unique_missiles = sorted(visible_df['MissileID'].unique()) if not visible_df.empty else []
        unique_satellites = sorted(visible_df['SatelliteID'].unique()) if not visible_df.empty else []

        # 如果没有数据，从Y轴位置推导导弹和卫星
        if not unique_missiles or not unique_satellites:
            all_combos = list(y_positions.keys())
            unique_missiles = sorted(list(set([combo.split('_')[0] for combo in all_combos])))
            unique_satellites = sorted(list(set(['_'.join(combo.split('_')[1:]) for combo in all_combos])))

        # 为每个Y轴位置对应的导弹-卫星组合生成完整时间轴

        for combo_key in y_positions.keys():
            # 导弹ID格式: GlobalThreat_XXX_XXXX 或其他格式
            # 卫星ID格式: SatelliteXX
            # 组合格式: MissileID_SatelliteID
            parts = combo_key.split('_')
            if len(parts) >= 2:
                # 查找以"Satellite"开头的部分作为卫星ID
                satellite_parts = [part for part in parts if part.startswith('Satellite')]
                if satellite_parts:
                    satellite_id = satellite_parts[0]  # 取第一个匹配的卫星ID
                    # 导弹ID是除了卫星ID之外的所有部分
                    missile_parts = []
                    for part in parts:
                        if part == satellite_id:
                            break
                        missile_parts.append(part)
                    missile_id = '_'.join(missile_parts)
                else:
                    # 如果没有找到Satellite开头的部分，使用最后一部分作为卫星ID
                    missile_id = '_'.join(parts[:-1])
                    satellite_id = parts[-1]
            else:
                continue  # 跳过格式不正确的组合

            # 获取该组合的现有任务
            combo_tasks = visible_df[
                (visible_df['MissileID'] == missile_id) &
                (visible_df['SatelliteID'] == satellite_id)
            ].copy()

            if combo_tasks.empty:
                # 如果没有任何任务，为整个时间范围填充虚拟任务
                virtual_task = {
                    'Start': min_time,
                    'End': max_time,
                    'SatelliteID': satellite_id,
                    'MissileID': missile_id,
                    'Type': 'virtual_atomic_task',
                    'TaskIndex': 0,
                    'TaskID': f'virtual_{satellite_id}_{missile_id}_full',
                    'TaskName': f'{satellite_id} → {missile_id} 虚拟原子任务',
                    'Duration': (max_time - min_time).total_seconds(),
                    'Category': '虚拟原子任务',
                    'Level': 'virtual',
                    'VisibilityInfo': {},
                    'CoverageRatio': 0.0
                }
                complete_tasks.append(virtual_task)
            else:
                # 如果有任务，先添加所有原始任务
                for _, task in combo_tasks.iterrows():
                    complete_tasks.append(task.to_dict())

                # 然后检查是否需要填充空隙
                combo_tasks_sorted = combo_tasks.sort_values('Start')

                # 检查开始前的空隙
                first_task_start = combo_tasks_sorted.iloc[0]['Start']
                if min_time < first_task_start:
                    virtual_task = {
                        'Start': min_time,
                        'End': first_task_start,
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'Type': 'virtual_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{satellite_id}_{missile_id}_start',
                        'TaskName': f'{satellite_id} → {missile_id} 虚拟原子任务',
                        'Duration': (first_task_start - min_time).total_seconds(),
                        'Category': '虚拟原子任务',
                        'Level': 'virtual',
                        'VisibilityInfo': {},
                        'CoverageRatio': 0.0
                    }
                    complete_tasks.append(virtual_task)

                # 检查任务间的空隙
                for i in range(len(combo_tasks_sorted) - 1):
                    current_task_end = combo_tasks_sorted.iloc[i]['End']
                    next_task_start = combo_tasks_sorted.iloc[i + 1]['Start']

                    if current_task_end < next_task_start:
                        virtual_task = {
                            'Start': current_task_end,
                            'End': next_task_start,
                            'SatelliteID': satellite_id,
                            'MissileID': missile_id,
                            'Type': 'virtual_atomic_task',
                            'TaskIndex': 0,
                            'TaskID': f'virtual_{satellite_id}_{missile_id}_gap_{i}',
                            'TaskName': f'{satellite_id} → {missile_id} 虚拟原子任务',
                            'Duration': (next_task_start - current_task_end).total_seconds(),
                            'Category': '虚拟原子任务',
                            'Level': 'virtual',
                            'VisibilityInfo': {},
                            'CoverageRatio': 0.0
                        }
                        complete_tasks.append(virtual_task)

                # 检查结束后的空隙
                last_task_end = combo_tasks_sorted.iloc[-1]['End']
                if last_task_end < max_time:
                    virtual_task = {
                        'Start': last_task_end,
                        'End': max_time,
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'Type': 'virtual_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{satellite_id}_{missile_id}_end',
                        'TaskName': f'{satellite_id} → {missile_id} 虚拟原子任务',
                        'Duration': (max_time - last_task_end).total_seconds(),
                        'Category': '虚拟原子任务',
                        'Level': 'virtual',
                        'VisibilityInfo': {},
                        'CoverageRatio': 0.0
                    }
                    complete_tasks.append(virtual_task)

        return pd.DataFrame(complete_tasks)

    def _fill_virtual_tasks_for_meta_timeline(self, meta_df, min_time, max_time, y_positions):
        """为元任务填充虚拟任务，确保时间轴完整"""
        complete_tasks = []

        # 获取所有唯一的导弹ID
        unique_missiles = sorted(meta_df['MissileID'].unique()) if not meta_df.empty else []

        # 为每个导弹生成完整时间轴
        for missile_id in unique_missiles:
            # 获取该导弹的现有任务
            missile_tasks = meta_df[meta_df['MissileID'] == missile_id].copy()

            if missile_tasks.empty:
                # 如果没有任何任务，为整个时间范围填充虚拟任务
                virtual_task = {
                    'Start': min_time,
                    'End': max_time,
                    'MissileID': missile_id,
                    'Type': 'meta_atomic_task',
                    'TaskIndex': 0,
                    'TaskID': f'virtual_{missile_id}_full',
                    'TaskName': f'{missile_id} 虚拟元子任务',
                    'Duration': (max_time - min_time).total_seconds(),
                    'Category': '虚拟元子任务',
                    'Level': 'virtual_atomic',
                    'TaskType': 'virtual_meta_task',
                    'IsRealTask': False,
                    'IsVirtualTask': True
                }
                complete_tasks.append(virtual_task)
            else:
                # 如果有任务，先添加所有原始任务
                for _, task in missile_tasks.iterrows():
                    complete_tasks.append(task.to_dict())

                # 然后检查是否需要填充空隙
                missile_tasks_sorted = missile_tasks.sort_values('Start')

                # 检查开始前的空隙
                first_task_start = missile_tasks_sorted.iloc[0]['Start']
                if min_time < first_task_start:
                    virtual_task = {
                        'Start': min_time,
                        'End': first_task_start,
                        'MissileID': missile_id,
                        'Type': 'meta_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{missile_id}_start',
                        'TaskName': f'{missile_id} 虚拟元子任务',
                        'Duration': (first_task_start - min_time).total_seconds(),
                        'Category': '虚拟元子任务',
                        'Level': 'virtual_atomic',
                        'TaskType': 'virtual_meta_task',
                        'IsRealTask': False,
                        'IsVirtualTask': True
                    }
                    complete_tasks.append(virtual_task)

                # 检查任务间的空隙
                for i in range(len(missile_tasks_sorted) - 1):
                    current_task_end = missile_tasks_sorted.iloc[i]['End']
                    next_task_start = missile_tasks_sorted.iloc[i + 1]['Start']

                    if current_task_end < next_task_start:
                        virtual_task = {
                            'Start': current_task_end,
                            'End': next_task_start,
                            'MissileID': missile_id,
                            'Type': 'meta_atomic_task',
                            'TaskIndex': 0,
                            'TaskID': f'virtual_{missile_id}_gap_{i}',
                            'TaskName': f'{missile_id} 虚拟元子任务',
                            'Duration': (next_task_start - current_task_end).total_seconds(),
                            'Category': '虚拟元子任务',
                            'Level': 'virtual_atomic',
                            'TaskType': 'virtual_meta_task',
                            'IsRealTask': False,
                            'IsVirtualTask': True
                        }
                        complete_tasks.append(virtual_task)

                # 检查结束后的空隙
                last_task_end = missile_tasks_sorted.iloc[-1]['End']
                if last_task_end < max_time:
                    virtual_task = {
                        'Start': last_task_end,
                        'End': max_time,
                        'MissileID': missile_id,
                        'Type': 'meta_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{missile_id}_end',
                        'TaskName': f'{missile_id} 虚拟元子任务',
                        'Duration': (max_time - last_task_end).total_seconds(),
                        'Category': '虚拟元子任务',
                        'Level': 'virtual_atomic',
                        'TaskType': 'virtual_meta_task',
                        'IsRealTask': False,
                        'IsVirtualTask': True
                    }
                    complete_tasks.append(virtual_task)

        return pd.DataFrame(complete_tasks)

    def _setup_time_axis(self, ax, min_time, max_time):
        """设置时间轴格式"""
        # 设置时间格式
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))
        ax.xaxis.set_minor_locator(mdates.MinuteLocator(interval=30))

        # 设置时间范围
        ax.set_xlim(mdates.date2num(min_time), mdates.date2num(max_time))

        # 旋转时间标签
        plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')

    def create_summary_report(self, meta_df, visible_df):
        """创建任务统计报告"""
        print("\n" + "="*60)
        print("📊 航天元任务规划统计报告")
        print("="*60)

        # 元任务统计
        if not meta_df.empty:
            print("\n🎯 元任务统计:")
            missile_count = meta_df['MissileID'].nunique()
            atomic_task_count = len(meta_df[meta_df['Type'] == 'meta_atomic_task'])
            print(f"  导弹目标数量: {missile_count}")
            print(f"  元子任务总数: {atomic_task_count}")

            # 时间统计
            planning_start = meta_df['Start'].min()
            planning_end = meta_df['End'].max()
            planning_duration = planning_end - planning_start
            print(f"  规划周期: {planning_start} → {planning_end}")
            print(f"  规划时长: {planning_duration}")

        # 可见元任务统计
        if not visible_df.empty:
            print("\n👁️ 可见元任务统计:")
            satellite_count = visible_df['SatelliteID'].nunique()
            visible_task_count = len(visible_df[visible_df['Type'] == 'visible_meta_task'])
            virtual_task_count = len(visible_df[visible_df['Type'] == 'virtual_atomic_task'])

            print(f"  卫星数量: {satellite_count}")
            print(f"  可见元任务数量: {visible_task_count}")
            print(f"  虚拟原子任务数量: {virtual_task_count}")

            if visible_task_count + virtual_task_count > 0:
                visibility_ratio = visible_task_count / (visible_task_count + virtual_task_count) * 100
                print(f"  可见性比例: {visibility_ratio:.2f}%")

        print("="*60)

def main():
    """主函数"""
    import sys
    import glob
    from pathlib import Path

    try:
        print("启动航天元任务规划甘特图生成器")

        # 创建甘特图生成器
        gantt = AerospaceMetaTaskGantt()

        # 确定数据文件
        if len(sys.argv) > 1:
            # 使用命令行参数指定的文件
            data_file = sys.argv[1]
            print(f"📁 使用指定数据文件: {data_file}")
        else:
            # 自动查找最新的数据文件
            # data_files = glob.glob('output/rolling_collections/session_20250804_013652/collections/collection_*/data/meta_task_data.json')
            
            # if data_files:
            #     data_file = max(data_files, key=lambda x: Path(x).stat().st_mtime)
            #     print(f"📁 使用最新数据文件: {data_file}")
            # else:
            #     print("❌ 未找到数据文件")
            #     return
            data_file = 'output/rolling_collections\session_20250804_013652\collections\collection_045\data\meta_task_data.json'

        # 检查文件是否存在
        if not Path(data_file).exists():
            print(f"❌ 数据文件不存在: {data_file}")
            return

        # 加载数据
        gantt.load_data(data_file)

        # 提取元任务数据
        print("\n📊 提取元任务数据...")
        meta_df = gantt.extract_meta_task_data()
        print(f"✅ 提取到 {len(meta_df)} 条元任务数据")

        # 提取可见元任务数据
        print("\n👁️ 提取可见元任务数据...")
        visible_df = gantt.extract_visible_meta_task_data()
        print(f"✅ 提取到 {len(visible_df)} 条可见元任务数据")

        # 创建统计报告
        gantt.create_summary_report(meta_df, visible_df)

        # 创建专业甘特图
        print("\n🎨 创建专业航天元任务甘特图...")
        result = gantt.create_professional_gantt_chart(
            meta_df, visible_df  # 自动根据数据范围确定时间轴
        )

        # 处理返回结果
        if len(result) == 4:
            fig, (ax1, ax2), saved_path, save_success = result
        else:
            fig, (ax1, ax2) = result
            saved_path = "output/charts/aerospace_meta_task_gantt.png"
            save_success = True

        # 不显示图表（在自动化环境中）
        if len(sys.argv) <= 1:
            plt.show()

        print("\n航天元任务规划甘特图创建完成！")
        if save_success:
            print(f"图表已保存到: {saved_path}")
        else:
            print("⚠️ 图表保存失败，但图表已生成")

    except FileNotFoundError:
        print("数据文件未找到，请确保已运行元任务数据采集系统")
    except Exception as e:
        print(f"创建甘特图失败: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
