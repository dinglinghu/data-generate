"""
èˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾ç”Ÿæˆå™¨
åŸºäºå…ƒä»»åŠ¡å®šä¹‰å’Œå¯è§å…ƒä»»åŠ¡å®šä¹‰åˆ›å»ºä¸“ä¸šçš„ä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾
"""

import json
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from matplotlib.patches import Rectangle
import seaborn as sns
from matplotlib.patches import Patch
import matplotlib.patches as mpatches
import yaml
import sys
import os
from pathlib import Path

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

class AerospaceMetaTaskGantt:
    """èˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾ç”Ÿæˆå™¨"""

    def __init__(self, config_path="config/config.yaml"):
        # åŠ è½½é…ç½®æ–‡ä»¶
        self.config = self._load_config(config_path)

        # è·å–å¯è§†åŒ–é…ç½®
        viz_config = self.config.get('visualization', {})
        gantt_config = viz_config.get('gantt_chart', {})

        # é¢œè‰²é…ç½®
        self.colors = gantt_config.get('colors', {})

        # å›¾è¡¨é…ç½®
        self.figure_config = {
            'size': gantt_config.get('figure_size', [24, 16]),
            'height_ratios': gantt_config.get('height_ratios', [2, 3]),
            'dpi': gantt_config.get('dpi', 300)
        }

        # æ—¶é—´è½´é…ç½®
        self.time_config = gantt_config.get('time_axis', {})

        # ä»»åŠ¡æ¡é…ç½®
        self.task_config = gantt_config.get('task_bars', {})

        # Yè½´é…ç½®
        self.y_config = gantt_config.get('y_axis', {})

        # æ–‡å­—é…ç½®
        self.text_config = gantt_config.get('text', {})

        # ç½‘æ ¼é…ç½®
        self.grid_config = gantt_config.get('grid', {})

    def _load_config(self, config_path):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        try:
            config_file = Path(config_path)
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f)
            else:
                print(f"âš ï¸ é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}ï¼Œä½¿ç”¨é»˜è®¤é…ç½®")
                return self._get_default_config()
        except Exception as e:
            print(f"âŒ åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}ï¼Œä½¿ç”¨é»˜è®¤é…ç½®")
            return self._get_default_config()

    def _get_default_config(self):
        """è·å–é»˜è®¤é…ç½®"""
        return {
            'visualization': {
                'gantt_chart': {
                    'figure_size': [24, 16],
                    'height_ratios': [2, 3],
                    'dpi': 300,
                    'time_axis': {
                        'buffer_minutes': 5,
                        'default_window_hours': 2,
                        'hour_interval': 1,
                        'minute_interval': 30,
                        'label_rotation': 45
                    },
                    'task_bars': {
                        'meta_task': {
                            'height': 0.4,
                            'linewidth': 1,
                            'alpha_real': 0.9,
                            'alpha_virtual': 0.6,
                            'min_duration_for_label': 30
                        },
                        'visible_task': {
                            'height': 0.7,
                            'linewidth_visible': 2,
                            'linewidth_virtual': 1,
                            'alpha_visible': 0.9,
                            'alpha_virtual': 0.6,
                            'min_duration_for_label': 30
                        }
                    },
                    'y_axis': {
                        'spacing_between_missiles': 0.5,
                        'spacing_between_combos': 0.5,
                        'label_fontsize_meta': 10,
                        'label_fontsize_visible': 9
                    },
                    'text': {
                        'title_fontsize': 18,
                        'subtitle_fontsize': 14,
                        'label_fontsize': 12,
                        'task_label_fontsize': 8,
                        'legend_fontsize': 10,
                        'legend_alpha': 0.9
                    },
                    'grid': {
                        'enable': True,
                        'alpha': 0.3,
                        'linestyle': "-",
                        'linewidth': 0.5
                    },
                    'colors': {
                        'background': '#fafafa',
                        'grid_major': '#e0e0e0',
                        'text_primary': '#212121',
                        'visible_meta_task': '#4caf50',
                        'visible_meta_border': '#2e7d32',
                        'virtual_atomic_task': '#ff9800',
                        'virtual_atomic_border': '#f57c00',
                        'visible_virtual_atomic_task': '#e0e0e0',
                        'visible_virtual_atomic_border': '#1976d2',
                        'real_meta_task': '#4caf50',
                        'real_meta_border': '#2e7d32',
                        'virtual_meta_task': '#e8f4fd',
                        'virtual_meta_border': '#1e88e5',
                        'meta_task_background': '#e8f4fd',
                        'meta_task_border': '#1e88e5',
                        'meta_task_text': '#0d47a1'
                    }
                }
            }
        }
    
    def load_data(self, json_file_path):
        """åŠ è½½å…ƒä»»åŠ¡æ•°æ®"""
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # é€‰æ‹©ç¬¬ä¸€ä¸ªæ•°æ®é‡‡æ ·ç‚¹
        if isinstance(data, list):
            self.sample_data = data[0]
        else:
            self.sample_data = data
            
        collection_time = self.sample_data.get('collection_time', 'Unknown')
        print(f"âœ… æ•°æ®åŠ è½½å®Œæˆï¼Œé‡‡æ ·æ—¶é—´: {collection_time}")
        
        # è§£ææ•°æ®ç»“æ„
        self.meta_tasks = self.sample_data.get('meta_tasks', {})
        self.visible_meta_tasks = self.sample_data.get('visible_meta_tasks', {})
        
        print(f"ğŸ“Š å…ƒä»»åŠ¡æ•°æ®: {len(self.meta_tasks.get('meta_tasks', {}))} ä¸ªå¯¼å¼¹")
        print(f"ğŸ‘ï¸ å¯è§å…ƒä»»åŠ¡æ•°æ®: {len(self.visible_meta_tasks.get('constellation_visible_task_sets', {}))} é¢—å«æ˜Ÿ")
    
    def parse_time(self, time_str):
        """è§£ææ—¶é—´å­—ç¬¦ä¸²"""
        try:
            if isinstance(time_str, str):
                # ISOæ ¼å¼ï¼š2025-07-25T14:07:02
                if 'T' in time_str:
                    return datetime.fromisoformat(time_str.replace('Z', '+00:00'))
                # æ ‡å‡†æ ¼å¼ï¼š2025-07-25 14:07:02
                elif '-' in time_str and ':' in time_str:
                    return datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S")
                # STKæ ¼å¼ï¼š25 Jul 2025 14:07:02.000
                else:
                    return datetime.strptime(time_str, "%d %b %Y %H:%M:%S.%f")
            return time_str
        except:
            try:
                # å¤‡ç”¨STKæ ¼å¼ï¼š25 Jul 2025 14:07:02
                return datetime.strptime(time_str, "%d %b %Y %H:%M:%S")
            except:
                print(f"âš ï¸ æ— æ³•è§£ææ—¶é—´æ ¼å¼: {time_str}")
                return datetime.now()
    
    def extract_meta_task_data(self):
        """æå–å…ƒä»»åŠ¡æ•°æ®"""
        meta_task_data = []
        
        # è·å–å…ƒä»»åŠ¡è§„åˆ’å‘¨æœŸä¿¡æ¯
        planning_info = self.meta_tasks.get('planning_cycle_info', {})
        planning_start_str = planning_info.get('planning_start_time', '')
        planning_end_str = planning_info.get('planning_end_time', '')

        if planning_start_str and planning_end_str:
            planning_start = self.parse_time(planning_start_str)
            planning_end = self.parse_time(planning_end_str)
            print(f"ğŸ“… å…ƒä»»åŠ¡è§„åˆ’å‘¨æœŸ: {planning_start} â†’ {planning_end}")
        else:
            print(f"ğŸ“… å…ƒä»»åŠ¡è§„åˆ’å‘¨æœŸ: ä»æ•°æ®ä¸­è‡ªåŠ¨æ¨å¯¼")
        
        # å¤„ç†æ¯ä¸ªå¯¼å¼¹çš„å…ƒä»»åŠ¡
        missile_tasks = self.meta_tasks.get('meta_tasks', {})
        
        for missile_id, missile_data in missile_tasks.items():
            atomic_tasks = missile_data.get('atomic_tasks', [])
            

            
            # æ·»åŠ æ¯ä¸ªå…ƒå­ä»»åŠ¡ï¼ˆåŒºåˆ†çœŸå®ä»»åŠ¡å’Œè™šæ‹Ÿä»»åŠ¡ï¼‰
            for task in atomic_tasks:
                task_type = task.get('task_type', 'atomic_meta_task')
                is_real_task = task_type == 'real_meta_task'
                is_virtual_task = task_type == 'virtual_meta_task'

                # ç¡®å®šä»»åŠ¡ç±»åˆ«å’Œåç§°
                if is_real_task:
                    category = 'çœŸå®å…ƒå­ä»»åŠ¡'
                    task_name = f'{missile_id} çœŸå®ä»»åŠ¡ {task.get("task_index", "")}'
                    task_level = 'real_atomic'
                elif is_virtual_task:
                    category = 'è™šæ‹Ÿå…ƒå­ä»»åŠ¡'
                    task_name = f'{missile_id} è™šæ‹Ÿä»»åŠ¡ {task.get("task_index", "")}'
                    task_level = 'virtual_atomic'
                else:
                    category = 'å…ƒå­ä»»åŠ¡'
                    task_name = f'{missile_id} å…ƒå­ä»»åŠ¡ {task.get("task_index", "")}'
                    task_level = 'atomic'

                meta_task_data.append({
                    'Type': 'meta_atomic_task',
                    'MissileID': missile_id,
                    'TaskID': task.get('task_id', ''),
                    'TaskIndex': task.get('task_index', 0),
                    'TaskName': task_name,
                    'Start': self.parse_time(task['start_time']),
                    'End': self.parse_time(task['end_time']),
                    'Duration': task.get('duration_seconds', 0),
                    'Category': category,
                    'Level': task_level,
                    'TaskType': task_type,
                    'IsRealTask': is_real_task,
                    'IsVirtualTask': is_virtual_task
                })
        
        return pd.DataFrame(meta_task_data)
    
    def extract_visible_meta_task_data(self):
        """æå–å¯è§å…ƒä»»åŠ¡æ•°æ®"""
        visible_task_data = []
        
        constellation_sets = self.visible_meta_tasks.get('constellation_visible_task_sets', {})
        
        for satellite_id, satellite_data in constellation_sets.items():
            missile_tasks = satellite_data.get('missile_tasks', {})
            
            for missile_id, task_data in missile_tasks.items():
                # å¤„ç†å¯è§å…ƒä»»åŠ¡
                visible_tasks = task_data.get('visible_tasks', [])
                for task in visible_tasks:
                    visible_task_data.append({
                        'Type': 'visible_meta_task',
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'TaskID': task.get('task_id', ''),
                        'TaskIndex': task.get('task_index', 0),
                        'TaskName': f'{satellite_id} â†’ {missile_id} å¯è§å…ƒä»»åŠ¡',
                        'Start': self.parse_time(task['start_time']),
                        'End': self.parse_time(task['end_time']),
                        'Duration': task.get('duration_seconds', 0),
                        'Category': 'å¯è§å…ƒä»»åŠ¡',
                        'Level': 'visible',
                        'VisibilityInfo': task.get('visibility_info', {}),
                        'CoverageRatio': task.get('visibility_info', {}).get('coverage_ratio', 1.0)
                    })
                
                # å¤„ç†è™šæ‹ŸåŸå­ä»»åŠ¡ï¼ˆé‡‡æ ·æ˜¾ç¤ºï¼‰
                virtual_tasks = task_data.get('virtual_tasks', [])
                for i, task in enumerate(virtual_tasks):
                    if i % 10 == 0:  # æ¯10ä¸ªæ˜¾ç¤º1ä¸ªï¼Œé¿å…è¿‡äºå¯†é›†
                        visible_task_data.append({
                            'Type': 'virtual_atomic_task',
                            'SatelliteID': satellite_id,
                            'MissileID': missile_id,
                            'TaskID': task.get('task_id', ''),
                            'TaskIndex': task.get('task_index', 0),
                            'TaskName': f'{satellite_id} â†’ {missile_id} è™šæ‹ŸåŸå­ä»»åŠ¡',
                            'Start': self.parse_time(task['start_time']),
                            'End': self.parse_time(task['end_time']),
                            'Duration': task.get('duration_seconds', 0),
                            'Category': 'è™šæ‹ŸåŸå­ä»»åŠ¡',
                            'Level': 'virtual',
                            'VisibilityInfo': task.get('visibility_info', {})
                        })
        
        return pd.DataFrame(visible_task_data)
    
    def create_professional_gantt_chart(self, meta_df, visible_df, time_window_hours=None, output_path=None):
        """åˆ›å»ºä¸“ä¸šçš„èˆªå¤©å…ƒä»»åŠ¡ç”˜ç‰¹å›¾ï¼Œè‡ªåŠ¨æ ¹æ®æ•°æ®èŒƒå›´ç¡®å®šæ—¶é—´è½´"""

        # åˆ›å»ºå›¾å½¢
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=self.figure_config['size'],
                                       gridspec_kw={'height_ratios': self.figure_config['height_ratios']})
        fig.patch.set_facecolor(self.colors.get('background', '#fafafa'))

        # æ™ºèƒ½ç¡®å®šæ—¶é—´çª—å£ - ä»¥å…ƒä»»åŠ¡çš„æ—¶é—´è½´ä¸ºå‡†
        if not meta_df.empty:
            # ä¼˜å…ˆä½¿ç”¨å…ƒä»»åŠ¡çš„æ—¶é—´èŒƒå›´
            meta_start_times = meta_df['Start'].tolist()
            meta_end_times = meta_df['End'].tolist()

            # ç¡®å®šå…ƒä»»åŠ¡çš„æ—¶é—´èŒƒå›´
            data_min_time = min(meta_start_times)
            data_max_time = max(meta_end_times)

            # æ·»åŠ ç¼“å†²æ—¶é—´
            buffer_minutes = self.time_config.get('buffer_minutes', 5)
            min_time = data_min_time - timedelta(minutes=buffer_minutes)
            max_time = data_max_time + timedelta(minutes=buffer_minutes)

            # å¦‚æœæŒ‡å®šäº†æ—¶é—´çª—å£ï¼Œç¡®ä¿ä¸å°äºæ•°æ®èŒƒå›´
            if time_window_hours and time_window_hours > 0:
                window_max_time = min_time + timedelta(hours=time_window_hours)
                if window_max_time > max_time:
                    max_time = window_max_time

            # è®¡ç®—å®é™…æ—¶é—´è·¨åº¦
            actual_duration = max_time - min_time
            duration_hours = actual_duration.total_seconds() / 3600

            print(f"ğŸ• å…ƒä»»åŠ¡æ—¶é—´èŒƒå›´: {data_min_time} â†’ {data_max_time}")
            print(f"ğŸ• å›¾è¡¨æ—¶é—´èŒƒå›´: {min_time} â†’ {max_time}")
            print(f"â±ï¸ æ—¶é—´è·¨åº¦: {duration_hours:.2f} å°æ—¶")
            print(f"ğŸ“Š åŸå§‹å…ƒä»»åŠ¡æ•°æ®: {len(meta_df)} æ¡")
            print(f"ğŸ‘ï¸ åŸå§‹å¯è§ä»»åŠ¡æ•°æ®: {len(visible_df)} æ¡")

            # ä½¿ç”¨å…ƒä»»åŠ¡çš„æ—¶é—´èŒƒå›´ç­›é€‰å¯è§ä»»åŠ¡æ•°æ®
            meta_filtered = meta_df
            if not visible_df.empty:
                visible_filtered = visible_df[
                    (visible_df['Start'] >= min_time) &
                    (visible_df['End'] <= max_time)
                ].copy()
            else:
                visible_filtered = visible_df

            print(f"ğŸ“Š ç­›é€‰åå…ƒä»»åŠ¡æ•°æ®: {len(meta_filtered)} æ¡")
            print(f"ğŸ‘ï¸ ç­›é€‰åå¯è§ä»»åŠ¡æ•°æ®: {len(visible_filtered)} æ¡")

        elif not visible_df.empty:
            # å¦‚æœæ²¡æœ‰å…ƒä»»åŠ¡ä½†æœ‰å¯è§ä»»åŠ¡ï¼Œä½¿ç”¨å¯è§ä»»åŠ¡çš„æ—¶é—´èŒƒå›´
            visible_start_times = visible_df['Start'].tolist()
            visible_end_times = visible_df['End'].tolist()

            data_min_time = min(visible_start_times)
            data_max_time = max(visible_end_times)

            buffer_minutes = self.time_config.get('buffer_minutes', 5)
            min_time = data_min_time - timedelta(minutes=buffer_minutes)
            max_time = data_max_time + timedelta(minutes=buffer_minutes)

            meta_filtered = meta_df
            visible_filtered = visible_df
            print("âš ï¸ æ²¡æœ‰å…ƒä»»åŠ¡æ•°æ®ï¼Œä½¿ç”¨å¯è§ä»»åŠ¡æ—¶é—´èŒƒå›´")
        else:
            # å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œè®¾ç½®é»˜è®¤æ—¶é—´èŒƒå›´
            min_time = datetime.now()
            default_hours = time_window_hours or self.time_config.get('default_window_hours', 2)
            max_time = min_time + timedelta(hours=default_hours)
            meta_filtered = meta_df
            visible_filtered = visible_df
            print("âš ï¸ æ²¡æœ‰ä»»ä½•ä»»åŠ¡æ•°æ®")
        
        # ç»˜åˆ¶å…ƒä»»åŠ¡ç”˜ç‰¹å›¾
        self._draw_meta_task_gantt(ax1, meta_filtered, min_time, max_time)
        
        # ç»˜åˆ¶å¯è§å…ƒä»»åŠ¡ç”˜ç‰¹å›¾
        self._draw_visible_meta_task_gantt(ax2, visible_filtered, min_time, max_time)
        
        # è®¾ç½®æ•´ä½“æ ‡é¢˜
        collection_time = self.sample_data.get('collection_time', 'Unknown')
        title_fontsize = self.text_config.get('title_fontsize', 18)
        fig.suptitle(
            f'èˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾\næ•°æ®é‡‡æ ·æ—¶é—´: {collection_time}',
            fontsize=title_fontsize, fontweight='bold',
            color=self.colors.get('text_primary', '#212121')
        )
        
        plt.tight_layout()
        
        # ä¿å­˜å›¾è¡¨ - æ”¯æŒè‡ªå®šä¹‰è¾“å‡ºè·¯å¾„
        if output_path is None:
            output_path = 'output/charts/aerospace_meta_task_gantt.png'

        import os
        output_dir = os.path.dirname(output_path)
        if output_dir:  # åªæœ‰å½“ç›®å½•ä¸ä¸ºç©ºæ—¶æ‰åˆ›å»º
            os.makedirs(output_dir, exist_ok=True)
        dpi = self.figure_config.get('dpi', 300)

        try:
            plt.savefig(output_path, dpi=dpi, bbox_inches='tight',
                       facecolor=self.colors.get('background', '#fafafa'))
            print(f"âœ… ä¸“ä¸šèˆªå¤©å…ƒä»»åŠ¡ç”˜ç‰¹å›¾å·²ä¿å­˜åˆ°: {output_path}")
            save_success = True
        except Exception as e:
            print(f"âŒ ä¿å­˜ç”˜ç‰¹å›¾å¤±è´¥: {e}")
            # å°è¯•ä¿å­˜åˆ°å½“å‰ç›®å½•
            fallback_path = "aerospace_meta_task_gantt.png"
            try:
                plt.savefig(fallback_path, dpi=dpi, bbox_inches='tight',
                           facecolor=self.colors.get('background', '#fafafa'))
                print(f"âœ… ç”˜ç‰¹å›¾å·²ä¿å­˜åˆ°å¤‡ç”¨ä½ç½®: {fallback_path}")
                output_path = fallback_path
                save_success = True
            except Exception as e2:
                print(f"âŒ å¤‡ç”¨ä¿å­˜ä¹Ÿå¤±è´¥: {e2}")
                save_success = False

        return fig, (ax1, ax2), output_path, save_success

    def _draw_meta_task_gantt(self, ax, meta_df, min_time, max_time):
        """ç»˜åˆ¶å…ƒä»»åŠ¡ç”˜ç‰¹å›¾"""
        ax.set_facecolor(self.colors['background'])

        if meta_df.empty:
            ax.text(0.5, 0.5, 'æ— å…ƒä»»åŠ¡æ•°æ®', ha='center', va='center',
                   transform=ax.transAxes, fontsize=14)
            return

        # è·å–å”¯ä¸€çš„å¯¼å¼¹ID
        unique_missiles = sorted(meta_df['MissileID'].unique())

        # åˆ›å»ºYè½´ä½ç½®æ˜ å°„
        y_positions = {}
        y_pos = 0

        for missile_id in unique_missiles:
            # å…ƒå­ä»»åŠ¡
            y_positions[f'{missile_id}_atomic'] = y_pos
            y_pos += 1

            y_pos += 0.5  # å¯¼å¼¹é—´é—´éš”

        # ä¸ºå…ƒä»»åŠ¡å¡«å……è™šæ‹Ÿä»»åŠ¡ï¼Œç¡®ä¿æ—¶é—´è½´å®Œæ•´
        complete_meta_df = self._fill_virtual_tasks_for_meta_timeline(meta_df, min_time, max_time, y_positions)

        # ç»˜åˆ¶ä»»åŠ¡æ¡
        for idx, row in complete_meta_df.iterrows():
            start_time = row['Start']
            end_time = row['End']
            missile_id = row['MissileID']

            # æ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯å…ƒå­ä»»åŠ¡
            y_pos = y_positions[f'{missile_id}_atomic']

            # æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©é¢œè‰²
            task_type = row.get('TaskType', 'atomic_meta_task')
            is_real_task = row.get('IsRealTask', False)
            is_virtual_task = row.get('IsVirtualTask', False)

            if is_real_task or task_type == 'real_meta_task':
                color = self.colors['real_meta_task']
                edgecolor = self.colors['real_meta_border']
                alpha = 0.9
            elif is_virtual_task or task_type == 'virtual_meta_task':
                color = self.colors['virtual_meta_task']
                edgecolor = self.colors['virtual_meta_border']
                alpha = 0.9
            else:
                color = self.colors['meta_task_background']
                edgecolor = self.colors['meta_task_border']
                alpha = 0.9

            linewidth = 1
            height = 0.4

            # ç»˜åˆ¶çŸ©å½¢
            rect = Rectangle(
                (mdates.date2num(start_time), y_pos - height/2),
                mdates.date2num(end_time) - mdates.date2num(start_time),
                height,
                facecolor=color,
                alpha=alpha,
                edgecolor=edgecolor,
                linewidth=linewidth
            )
            ax.add_patch(rect)

            # æ·»åŠ ä»»åŠ¡æ ‡ç­¾
            if row['Type'] == 'meta_atomic_task':
                duration_minutes = (end_time - start_time).total_seconds() / 60
                if duration_minutes > 30:  # åªä¸ºè¾ƒé•¿çš„ä»»åŠ¡æ·»åŠ æ ‡ç­¾
                    mid_time = start_time + (end_time - start_time) / 2
                    task_index = row.get('TaskIndex', '')
                    ax.text(
                        mdates.date2num(mid_time), y_pos,
                        str(task_index),
                        ha='center', va='center',
                        fontsize=8, fontweight='bold',
                        color=self.colors['meta_task_text']
                    )

        # è®¾ç½®Yè½´
        y_labels = []
        y_ticks = []
        for missile_id in unique_missiles:
            y_labels.append(f'{missile_id} å…ƒå­ä»»åŠ¡')
            y_ticks.append(y_positions[f'{missile_id}_atomic'])

        ax.set_yticks(y_ticks)
        ax.set_yticklabels(y_labels, fontsize=10)
        ax.set_ylim(-0.5, max(y_ticks) + 1)

        # è®¾ç½®æ—¶é—´è½´
        self._setup_time_axis(ax, min_time, max_time)

        # è®¾ç½®æ ‡é¢˜å’Œæ ‡ç­¾
        ax.set_title('å…ƒä»»åŠ¡è§„åˆ’æ—¶é—´çº¿', fontsize=14, fontweight='bold',
                    color=self.colors['text_primary'], pad=15)
        ax.set_ylabel('å¯¼å¼¹ç›®æ ‡', fontsize=12, fontweight='bold')

        # æ·»åŠ ç½‘æ ¼
        ax.grid(True, alpha=0.3, color=self.colors['grid_major'], linestyle='-', linewidth=0.5)
        ax.set_axisbelow(True)

    def _draw_visible_meta_task_gantt(self, ax, visible_df, min_time, max_time):
        """ç»˜åˆ¶å¯è§å…ƒä»»åŠ¡ç”˜ç‰¹å›¾ - æŒ‰å¯¼å¼¹ç›®æ ‡ç»„ç»‡"""
        ax.set_facecolor(self.colors['background'])

        if visible_df.empty:
            ax.text(0.5, 0.5, 'æ— å¯è§å…ƒä»»åŠ¡æ•°æ®', ha='center', va='center',
                   transform=ax.transAxes, fontsize=14)
            return

        # è·å–å”¯ä¸€çš„å¯¼å¼¹å’Œå«æ˜Ÿ
        unique_missiles = sorted(visible_df['MissileID'].unique())
        unique_satellites = sorted(visible_df['SatelliteID'].unique())

        # åˆ›å»ºåˆ†å±‚Yè½´ä½ç½® - æŒ‰å¯¼å¼¹ç›®æ ‡ç»„ç»‡
        y_positions = {}
        y_labels = []
        y_pos = 0

        # è·å–Yè½´é—´è·é…ç½®
        y_axis_config = self.config.get('visualization', {}).get('gantt_chart', {}).get('y_axis', {})
        combo_spacing = y_axis_config.get('spacing_between_combos', 1.5)
        missile_spacing = y_axis_config.get('spacing_between_missiles', 1.0)

        for missile_id in unique_missiles:
            # ä¸ºæ¯ä¸ªå¯¼å¼¹ç›®æ ‡åˆ›å»ºä¸€ä¸ªåˆ†ç»„
            missile_satellites = []
            for satellite_id in unique_satellites:
                # ä¸ºæ‰€æœ‰å¯¼å¼¹-å«æ˜Ÿç»„åˆåˆ›å»ºYè½´ä½ç½®ï¼Œæ— è®ºæ˜¯å¦æœ‰æ•°æ®
                combo_key = f'{missile_id}_{satellite_id}'
                y_positions[combo_key] = y_pos
                y_labels.append(f'{missile_id} â†’ {satellite_id}')
                missile_satellites.append(satellite_id)
                y_pos += combo_spacing  # ä½¿ç”¨é…ç½®çš„ç»„åˆé—´é—´éš”

            # ä¸ºæ¯ä¸ªå¯¼å¼¹åˆ†ç»„æ·»åŠ åˆ†éš”ç©ºé—´
            if missile_satellites:
                y_pos += missile_spacing  # ä½¿ç”¨é…ç½®çš„å¯¼å¼¹é—´é—´éš”

        # ä¸ºæ¯ä¸ªå¯¼å¼¹-å«æ˜Ÿç»„åˆç”Ÿæˆå®Œæ•´çš„æ—¶é—´è½´å¡«å……
        complete_visible_df = self._generate_complete_visible_timeline(visible_df, y_positions, min_time, max_time)

        # ç»˜åˆ¶ä»»åŠ¡æ¡
        for idx, row in complete_visible_df.iterrows():
            start_time = row['Start']
            end_time = row['End']
            satellite_id = row['SatelliteID']
            missile_id = row['MissileID']

            combo_key = f'{missile_id}_{satellite_id}'  # æ³¨æ„ï¼šå¯¼å¼¹åœ¨å‰ï¼Œå«æ˜Ÿåœ¨å
            if combo_key not in y_positions:
                continue

            y_pos = y_positions[combo_key]

            # æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©é¢œè‰²å’Œæ ·å¼
            if row['Type'] == 'visible_meta_task':
                color = self.colors['visible_meta_task']
                alpha = 0.9
                edgecolor = self.colors['visible_meta_border']
                linewidth = 2
                height = 0.7
            else:  # virtual_atomic_task - ä½¿ç”¨æ–°çš„ç°è‰²æ ·å¼
                color = self.colors['visible_virtual_atomic_task']
                alpha = 0.8
                edgecolor = self.colors['visible_virtual_atomic_border']
                linewidth = 1
                height = 0.7  # ç»Ÿä¸€é«˜åº¦ä¸å¯è§å…ƒä»»åŠ¡ä¸€è‡´

            # ç»˜åˆ¶çŸ©å½¢
            rect = Rectangle(
                (mdates.date2num(start_time), y_pos - height/2),
                mdates.date2num(end_time) - mdates.date2num(start_time),
                height,
                facecolor=color,
                alpha=alpha,
                edgecolor=edgecolor,
                linewidth=linewidth
            )
            ax.add_patch(rect)

            # æ·»åŠ ä»»åŠ¡æ ‡ç­¾
            if row['Type'] == 'visible_meta_task':
                duration_minutes = (end_time - start_time).total_seconds() / 60
                if duration_minutes > 30:
                    mid_time = start_time + (end_time - start_time) / 2
                    task_index = row.get('TaskIndex', '')
                    ax.text(
                        mdates.date2num(mid_time), y_pos,
                        f'V{task_index}',
                        ha='center', va='center',
                        fontsize=8, fontweight='bold',
                        color='white'
                    )

        # è®¾ç½®Yè½´
        y_ticks = list(y_positions.values())

        ax.set_yticks(y_ticks)
        ax.set_yticklabels(y_labels, fontsize=9)
        ax.set_ylim(-0.5, max(y_ticks) + 1 if y_ticks else 1)

        # è®¾ç½®æ—¶é—´è½´
        self._setup_time_axis(ax, min_time, max_time)

        # è®¾ç½®æ ‡é¢˜å’Œæ ‡ç­¾
        ax.set_title('å¯è§å…ƒä»»åŠ¡ä¸è™šæ‹ŸåŸå­ä»»åŠ¡æ—¶é—´çº¿', fontsize=14, fontweight='bold',
                    color=self.colors['text_primary'], pad=15)
        ax.set_xlabel('æ—¶é—´ (å°æ—¶:åˆ†é’Ÿ)', fontsize=12, fontweight='bold')
        ax.set_ylabel('å¯¼å¼¹ç›®æ ‡ â†’ è§‚æµ‹å«æ˜Ÿ', fontsize=12, fontweight='bold')

        # æ·»åŠ ç½‘æ ¼
        ax.grid(True, alpha=0.3, color=self.colors['grid_major'], linestyle='-', linewidth=0.5)
        ax.set_axisbelow(True)

        # æ·»åŠ å›¾ä¾‹
        legend_elements = [
            Patch(facecolor=self.colors['visible_meta_task'], alpha=0.9,
                  edgecolor=self.colors['visible_meta_border'], label='å¯è§å…ƒä»»åŠ¡'),
            Patch(facecolor=self.colors['visible_virtual_atomic_task'], alpha=0.8,
                  edgecolor=self.colors['visible_virtual_atomic_border'], label='è™šæ‹ŸåŸå­ä»»åŠ¡'),
            Patch(facecolor=self.colors['meta_task_background'], alpha=0.9,
                  edgecolor=self.colors['meta_task_border'], label='å…ƒå­ä»»åŠ¡')
        ]
        ax.legend(handles=legend_elements, loc='upper right', fontsize=10, framealpha=0.9)

    def _generate_complete_visible_timeline(self, visible_df, y_positions, min_time, max_time):
        """ä¸ºæ¯ä¸ªå¯¼å¼¹-å«æ˜Ÿç»„åˆç”Ÿæˆå®Œæ•´çš„æ—¶é—´è½´å¡«å……"""
        import pandas as pd
        from datetime import timedelta

        complete_tasks = []

        # è·å–æ‰€æœ‰å”¯ä¸€çš„å¯¼å¼¹å’Œå«æ˜Ÿ
        unique_missiles = sorted(visible_df['MissileID'].unique()) if not visible_df.empty else []
        unique_satellites = sorted(visible_df['SatelliteID'].unique()) if not visible_df.empty else []

        # å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œä»Yè½´ä½ç½®æ¨å¯¼å¯¼å¼¹å’Œå«æ˜Ÿ
        if not unique_missiles or not unique_satellites:
            all_combos = list(y_positions.keys())
            unique_missiles = sorted(list(set([combo.split('_')[0] for combo in all_combos])))
            unique_satellites = sorted(list(set(['_'.join(combo.split('_')[1:]) for combo in all_combos])))

        # ä¸ºæ¯ä¸ªYè½´ä½ç½®å¯¹åº”çš„å¯¼å¼¹-å«æ˜Ÿç»„åˆç”Ÿæˆå®Œæ•´æ—¶é—´è½´

        for combo_key in y_positions.keys():
            # å¯¼å¼¹IDæ ¼å¼: GlobalThreat_XXX_XXXX æˆ–å…¶ä»–æ ¼å¼
            # å«æ˜ŸIDæ ¼å¼: SatelliteXX
            # ç»„åˆæ ¼å¼: MissileID_SatelliteID
            parts = combo_key.split('_')
            if len(parts) >= 2:
                # æŸ¥æ‰¾ä»¥"Satellite"å¼€å¤´çš„éƒ¨åˆ†ä½œä¸ºå«æ˜ŸID
                satellite_parts = [part for part in parts if part.startswith('Satellite')]
                if satellite_parts:
                    satellite_id = satellite_parts[0]  # å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å«æ˜ŸID
                    # å¯¼å¼¹IDæ˜¯é™¤äº†å«æ˜ŸIDä¹‹å¤–çš„æ‰€æœ‰éƒ¨åˆ†
                    missile_parts = []
                    for part in parts:
                        if part == satellite_id:
                            break
                        missile_parts.append(part)
                    missile_id = '_'.join(missile_parts)
                else:
                    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°Satelliteå¼€å¤´çš„éƒ¨åˆ†ï¼Œä½¿ç”¨æœ€åä¸€éƒ¨åˆ†ä½œä¸ºå«æ˜ŸID
                    missile_id = '_'.join(parts[:-1])
                    satellite_id = parts[-1]
            else:
                continue  # è·³è¿‡æ ¼å¼ä¸æ­£ç¡®çš„ç»„åˆ

            # è·å–è¯¥ç»„åˆçš„ç°æœ‰ä»»åŠ¡
            combo_tasks = visible_df[
                (visible_df['MissileID'] == missile_id) &
                (visible_df['SatelliteID'] == satellite_id)
            ].copy()

            if combo_tasks.empty:
                # å¦‚æœæ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œä¸ºæ•´ä¸ªæ—¶é—´èŒƒå›´å¡«å……è™šæ‹Ÿä»»åŠ¡
                virtual_task = {
                    'Start': min_time,
                    'End': max_time,
                    'SatelliteID': satellite_id,
                    'MissileID': missile_id,
                    'Type': 'virtual_atomic_task',
                    'TaskIndex': 0,
                    'TaskID': f'virtual_{satellite_id}_{missile_id}_full',
                    'TaskName': f'{satellite_id} â†’ {missile_id} è™šæ‹ŸåŸå­ä»»åŠ¡',
                    'Duration': (max_time - min_time).total_seconds(),
                    'Category': 'è™šæ‹ŸåŸå­ä»»åŠ¡',
                    'Level': 'virtual',
                    'VisibilityInfo': {},
                    'CoverageRatio': 0.0
                }
                complete_tasks.append(virtual_task)
            else:
                # å¦‚æœæœ‰ä»»åŠ¡ï¼Œå…ˆæ·»åŠ æ‰€æœ‰åŸå§‹ä»»åŠ¡
                for _, task in combo_tasks.iterrows():
                    complete_tasks.append(task.to_dict())

                # ç„¶åæ£€æŸ¥æ˜¯å¦éœ€è¦å¡«å……ç©ºéš™
                combo_tasks_sorted = combo_tasks.sort_values('Start')

                # æ£€æŸ¥å¼€å§‹å‰çš„ç©ºéš™
                first_task_start = combo_tasks_sorted.iloc[0]['Start']
                if min_time < first_task_start:
                    virtual_task = {
                        'Start': min_time,
                        'End': first_task_start,
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'Type': 'virtual_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{satellite_id}_{missile_id}_start',
                        'TaskName': f'{satellite_id} â†’ {missile_id} è™šæ‹ŸåŸå­ä»»åŠ¡',
                        'Duration': (first_task_start - min_time).total_seconds(),
                        'Category': 'è™šæ‹ŸåŸå­ä»»åŠ¡',
                        'Level': 'virtual',
                        'VisibilityInfo': {},
                        'CoverageRatio': 0.0
                    }
                    complete_tasks.append(virtual_task)

                # æ£€æŸ¥ä»»åŠ¡é—´çš„ç©ºéš™
                for i in range(len(combo_tasks_sorted) - 1):
                    current_task_end = combo_tasks_sorted.iloc[i]['End']
                    next_task_start = combo_tasks_sorted.iloc[i + 1]['Start']

                    if current_task_end < next_task_start:
                        virtual_task = {
                            'Start': current_task_end,
                            'End': next_task_start,
                            'SatelliteID': satellite_id,
                            'MissileID': missile_id,
                            'Type': 'virtual_atomic_task',
                            'TaskIndex': 0,
                            'TaskID': f'virtual_{satellite_id}_{missile_id}_gap_{i}',
                            'TaskName': f'{satellite_id} â†’ {missile_id} è™šæ‹ŸåŸå­ä»»åŠ¡',
                            'Duration': (next_task_start - current_task_end).total_seconds(),
                            'Category': 'è™šæ‹ŸåŸå­ä»»åŠ¡',
                            'Level': 'virtual',
                            'VisibilityInfo': {},
                            'CoverageRatio': 0.0
                        }
                        complete_tasks.append(virtual_task)

                # æ£€æŸ¥ç»“æŸåçš„ç©ºéš™
                last_task_end = combo_tasks_sorted.iloc[-1]['End']
                if last_task_end < max_time:
                    virtual_task = {
                        'Start': last_task_end,
                        'End': max_time,
                        'SatelliteID': satellite_id,
                        'MissileID': missile_id,
                        'Type': 'virtual_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{satellite_id}_{missile_id}_end',
                        'TaskName': f'{satellite_id} â†’ {missile_id} è™šæ‹ŸåŸå­ä»»åŠ¡',
                        'Duration': (max_time - last_task_end).total_seconds(),
                        'Category': 'è™šæ‹ŸåŸå­ä»»åŠ¡',
                        'Level': 'virtual',
                        'VisibilityInfo': {},
                        'CoverageRatio': 0.0
                    }
                    complete_tasks.append(virtual_task)

        return pd.DataFrame(complete_tasks)

    def _fill_virtual_tasks_for_meta_timeline(self, meta_df, min_time, max_time, y_positions):
        """ä¸ºå…ƒä»»åŠ¡å¡«å……è™šæ‹Ÿä»»åŠ¡ï¼Œç¡®ä¿æ—¶é—´è½´å®Œæ•´"""
        complete_tasks = []

        # è·å–æ‰€æœ‰å”¯ä¸€çš„å¯¼å¼¹ID
        unique_missiles = sorted(meta_df['MissileID'].unique()) if not meta_df.empty else []

        # ä¸ºæ¯ä¸ªå¯¼å¼¹ç”Ÿæˆå®Œæ•´æ—¶é—´è½´
        for missile_id in unique_missiles:
            # è·å–è¯¥å¯¼å¼¹çš„ç°æœ‰ä»»åŠ¡
            missile_tasks = meta_df[meta_df['MissileID'] == missile_id].copy()

            if missile_tasks.empty:
                # å¦‚æœæ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œä¸ºæ•´ä¸ªæ—¶é—´èŒƒå›´å¡«å……è™šæ‹Ÿä»»åŠ¡
                virtual_task = {
                    'Start': min_time,
                    'End': max_time,
                    'MissileID': missile_id,
                    'Type': 'meta_atomic_task',
                    'TaskIndex': 0,
                    'TaskID': f'virtual_{missile_id}_full',
                    'TaskName': f'{missile_id} è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                    'Duration': (max_time - min_time).total_seconds(),
                    'Category': 'è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                    'Level': 'virtual_atomic',
                    'TaskType': 'virtual_meta_task',
                    'IsRealTask': False,
                    'IsVirtualTask': True
                }
                complete_tasks.append(virtual_task)
            else:
                # å¦‚æœæœ‰ä»»åŠ¡ï¼Œå…ˆæ·»åŠ æ‰€æœ‰åŸå§‹ä»»åŠ¡
                for _, task in missile_tasks.iterrows():
                    complete_tasks.append(task.to_dict())

                # ç„¶åæ£€æŸ¥æ˜¯å¦éœ€è¦å¡«å……ç©ºéš™
                missile_tasks_sorted = missile_tasks.sort_values('Start')

                # æ£€æŸ¥å¼€å§‹å‰çš„ç©ºéš™
                first_task_start = missile_tasks_sorted.iloc[0]['Start']
                if min_time < first_task_start:
                    virtual_task = {
                        'Start': min_time,
                        'End': first_task_start,
                        'MissileID': missile_id,
                        'Type': 'meta_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{missile_id}_start',
                        'TaskName': f'{missile_id} è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                        'Duration': (first_task_start - min_time).total_seconds(),
                        'Category': 'è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                        'Level': 'virtual_atomic',
                        'TaskType': 'virtual_meta_task',
                        'IsRealTask': False,
                        'IsVirtualTask': True
                    }
                    complete_tasks.append(virtual_task)

                # æ£€æŸ¥ä»»åŠ¡é—´çš„ç©ºéš™
                for i in range(len(missile_tasks_sorted) - 1):
                    current_task_end = missile_tasks_sorted.iloc[i]['End']
                    next_task_start = missile_tasks_sorted.iloc[i + 1]['Start']

                    if current_task_end < next_task_start:
                        virtual_task = {
                            'Start': current_task_end,
                            'End': next_task_start,
                            'MissileID': missile_id,
                            'Type': 'meta_atomic_task',
                            'TaskIndex': 0,
                            'TaskID': f'virtual_{missile_id}_gap_{i}',
                            'TaskName': f'{missile_id} è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                            'Duration': (next_task_start - current_task_end).total_seconds(),
                            'Category': 'è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                            'Level': 'virtual_atomic',
                            'TaskType': 'virtual_meta_task',
                            'IsRealTask': False,
                            'IsVirtualTask': True
                        }
                        complete_tasks.append(virtual_task)

                # æ£€æŸ¥ç»“æŸåçš„ç©ºéš™
                last_task_end = missile_tasks_sorted.iloc[-1]['End']
                if last_task_end < max_time:
                    virtual_task = {
                        'Start': last_task_end,
                        'End': max_time,
                        'MissileID': missile_id,
                        'Type': 'meta_atomic_task',
                        'TaskIndex': 0,
                        'TaskID': f'virtual_{missile_id}_end',
                        'TaskName': f'{missile_id} è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                        'Duration': (max_time - last_task_end).total_seconds(),
                        'Category': 'è™šæ‹Ÿå…ƒå­ä»»åŠ¡',
                        'Level': 'virtual_atomic',
                        'TaskType': 'virtual_meta_task',
                        'IsRealTask': False,
                        'IsVirtualTask': True
                    }
                    complete_tasks.append(virtual_task)

        return pd.DataFrame(complete_tasks)

    def _setup_time_axis(self, ax, min_time, max_time):
        """è®¾ç½®æ—¶é—´è½´æ ¼å¼"""
        # è®¾ç½®æ—¶é—´æ ¼å¼
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))
        ax.xaxis.set_minor_locator(mdates.MinuteLocator(interval=30))

        # è®¾ç½®æ—¶é—´èŒƒå›´
        ax.set_xlim(mdates.date2num(min_time), mdates.date2num(max_time))

        # æ—‹è½¬æ—¶é—´æ ‡ç­¾
        plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')

    def create_summary_report(self, meta_df, visible_df):
        """åˆ›å»ºä»»åŠ¡ç»Ÿè®¡æŠ¥å‘Š"""
        print("\n" + "="*60)
        print("ğŸ“Š èˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç»Ÿè®¡æŠ¥å‘Š")
        print("="*60)

        # å…ƒä»»åŠ¡ç»Ÿè®¡
        if not meta_df.empty:
            print("\nğŸ¯ å…ƒä»»åŠ¡ç»Ÿè®¡:")
            missile_count = meta_df['MissileID'].nunique()
            atomic_task_count = len(meta_df[meta_df['Type'] == 'meta_atomic_task'])
            print(f"  å¯¼å¼¹ç›®æ ‡æ•°é‡: {missile_count}")
            print(f"  å…ƒå­ä»»åŠ¡æ€»æ•°: {atomic_task_count}")

            # æ—¶é—´ç»Ÿè®¡
            planning_start = meta_df['Start'].min()
            planning_end = meta_df['End'].max()
            planning_duration = planning_end - planning_start
            print(f"  è§„åˆ’å‘¨æœŸ: {planning_start} â†’ {planning_end}")
            print(f"  è§„åˆ’æ—¶é•¿: {planning_duration}")

        # å¯è§å…ƒä»»åŠ¡ç»Ÿè®¡
        if not visible_df.empty:
            print("\nğŸ‘ï¸ å¯è§å…ƒä»»åŠ¡ç»Ÿè®¡:")
            satellite_count = visible_df['SatelliteID'].nunique()
            visible_task_count = len(visible_df[visible_df['Type'] == 'visible_meta_task'])
            virtual_task_count = len(visible_df[visible_df['Type'] == 'virtual_atomic_task'])

            print(f"  å«æ˜Ÿæ•°é‡: {satellite_count}")
            print(f"  å¯è§å…ƒä»»åŠ¡æ•°é‡: {visible_task_count}")
            print(f"  è™šæ‹ŸåŸå­ä»»åŠ¡æ•°é‡: {virtual_task_count}")

            if visible_task_count + virtual_task_count > 0:
                visibility_ratio = visible_task_count / (visible_task_count + virtual_task_count) * 100
                print(f"  å¯è§æ€§æ¯”ä¾‹: {visibility_ratio:.2f}%")

        print("="*60)

def main():
    """ä¸»å‡½æ•°"""
    import sys
    import glob
    from pathlib import Path

    try:
        print("å¯åŠ¨èˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾ç”Ÿæˆå™¨")

        # åˆ›å»ºç”˜ç‰¹å›¾ç”Ÿæˆå™¨
        gantt = AerospaceMetaTaskGantt()

        # ç¡®å®šæ•°æ®æ–‡ä»¶
        if len(sys.argv) > 1:
            # ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°æŒ‡å®šçš„æ–‡ä»¶
            data_file = sys.argv[1]
            print(f"ğŸ“ ä½¿ç”¨æŒ‡å®šæ•°æ®æ–‡ä»¶: {data_file}")
        else:
            # è‡ªåŠ¨æŸ¥æ‰¾æœ€æ–°çš„æ•°æ®æ–‡ä»¶
            # data_files = glob.glob('output/rolling_collections/session_20250804_013652/collections/collection_*/data/meta_task_data.json')
            
            # if data_files:
            #     data_file = max(data_files, key=lambda x: Path(x).stat().st_mtime)
            #     print(f"ğŸ“ ä½¿ç”¨æœ€æ–°æ•°æ®æ–‡ä»¶: {data_file}")
            # else:
            #     print("âŒ æœªæ‰¾åˆ°æ•°æ®æ–‡ä»¶")
            #     return
            data_file = 'output/rolling_collections\session_20250804_013652\collections\collection_045\data\meta_task_data.json'

        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not Path(data_file).exists():
            print(f"âŒ æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨: {data_file}")
            return

        # åŠ è½½æ•°æ®
        gantt.load_data(data_file)

        # æå–å…ƒä»»åŠ¡æ•°æ®
        print("\nğŸ“Š æå–å…ƒä»»åŠ¡æ•°æ®...")
        meta_df = gantt.extract_meta_task_data()
        print(f"âœ… æå–åˆ° {len(meta_df)} æ¡å…ƒä»»åŠ¡æ•°æ®")

        # æå–å¯è§å…ƒä»»åŠ¡æ•°æ®
        print("\nğŸ‘ï¸ æå–å¯è§å…ƒä»»åŠ¡æ•°æ®...")
        visible_df = gantt.extract_visible_meta_task_data()
        print(f"âœ… æå–åˆ° {len(visible_df)} æ¡å¯è§å…ƒä»»åŠ¡æ•°æ®")

        # åˆ›å»ºç»Ÿè®¡æŠ¥å‘Š
        gantt.create_summary_report(meta_df, visible_df)

        # åˆ›å»ºä¸“ä¸šç”˜ç‰¹å›¾
        print("\nğŸ¨ åˆ›å»ºä¸“ä¸šèˆªå¤©å…ƒä»»åŠ¡ç”˜ç‰¹å›¾...")
        result = gantt.create_professional_gantt_chart(
            meta_df, visible_df  # è‡ªåŠ¨æ ¹æ®æ•°æ®èŒƒå›´ç¡®å®šæ—¶é—´è½´
        )

        # å¤„ç†è¿”å›ç»“æœ
        if len(result) == 4:
            fig, (ax1, ax2), saved_path, save_success = result
        else:
            fig, (ax1, ax2) = result
            saved_path = "output/charts/aerospace_meta_task_gantt.png"
            save_success = True

        # ä¸æ˜¾ç¤ºå›¾è¡¨ï¼ˆåœ¨è‡ªåŠ¨åŒ–ç¯å¢ƒä¸­ï¼‰
        if len(sys.argv) <= 1:
            plt.show()

        print("\nèˆªå¤©å…ƒä»»åŠ¡è§„åˆ’ç”˜ç‰¹å›¾åˆ›å»ºå®Œæˆï¼")
        if save_success:
            print(f"å›¾è¡¨å·²ä¿å­˜åˆ°: {saved_path}")
        else:
            print("âš ï¸ å›¾è¡¨ä¿å­˜å¤±è´¥ï¼Œä½†å›¾è¡¨å·²ç”Ÿæˆ")

    except FileNotFoundError:
        print("æ•°æ®æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿å·²è¿è¡Œå…ƒä»»åŠ¡æ•°æ®é‡‡é›†ç³»ç»Ÿ")
    except Exception as e:
        print(f"åˆ›å»ºç”˜ç‰¹å›¾å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
